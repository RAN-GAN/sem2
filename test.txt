Basic Linux Commands

1. TASK : To display user defined message
Command : echo
Syntax : echo “Message”
Explanation : This command displays the message after echo command on the screen.

2. TASK : To create a file
Command : vi
Syntax : vi filename
Explanation : This command creates the file and content can be typed.

3. TASK : To view a file
Command : cat
Syntax : cat filename
Explanation : This command displays the contents of specified file.

4. TASK : To display the files and folders present in the Login
Command : Is
Syntax : Is
Explanation : This command displays the files and folders present in login.

5. TASK : To copy a file
Command : cp
Syntax : cp sourcefile destfile
Explanation : This command produces a copy of the stored file and is stored

6. TASK : To rename or move a file
Command : mv
Syntax : mv sourcefile destfile
Explanation : Command moves content of source file to destination, then source file is deleted

7. TASK : To display the no. of characters in a file
Command : wc
Syntax : wc filename
Explanation : The command displays the no. of lines, words and characters of file

8. TASK : To display the online manual
Command : man
Syntax : man Is
Explanation : This command displays information about ls

9. TASK : To retrieve a part of the file
Command : head
Syntax : head –noofrows filename
Explanation : This command displays no. of rows from the top of the specified file.

10. TASK : To retrieve a part of the file
Command : tail
Syntax : tail –noofrows filename
Explanation : This command displays no. of rows from the bottom of the specified file.

11. TASK : To change a directory
Command : cd
Syntax : cd dirname
Explanation : This command switch one directory to another.

12. TASK : To create a directory
Command : mkdir
Syntax : mkdir dirname
Explanation : This command creates a new directory with specified name.

13. TASK : To delete a file
Command : rm
Syntax : rm filename
Explanation : This command deletes the specified file from directory

14. TASK : To delete a directory
Command : rmdir
Syntax : rmdir dirname
Explanation : This command deletes the specified directory

15. TASK : To sort the contents of a file
Command : sort
Syntax : sort filename
Explanation : This command sorts the contents of a file in ascending order.

16. TASK : To compress a given file or directory
Command : gzip
Syntax : gzip filename
Explanation : This command compress a given file or directory

17. TASK : To compare the contents of two files
Command : cmp
Syntax : cmp f1 f2
Explanation : The command compares a given file and displays the area which it differs

18. TASK : To find the difference between the contents of two files
Command : diff
Syntax : diff f1 f2
Explanation : The command compares a given file and displays the area from which it differs

19. TASK : To display the current working directory
Command : pwd
Syntax : pwd
Explanation : This displays current working directory showing this path.

20. TASK : To display calendar of current month
Command : cal
Syntax : cal 2016
Explanation : This displays the calendar of the current month on screen

21. TASK : To come out of sub directory
Command : cd
Syntax : cd ..
Explanation : This command helps is switch to main directory.

22. TASK : To display the user details
Command : whoami
Syntax : whoami
Explanation : This command displays current user of the system on the screen.

23. TASK : To match given pattern
Command : grep
Syntax : grep [- v –n -c] pattern filename
Explanation : command verifies filename and checks whether pattern present in file or not.

24. TASK : To gives permissions to given file
Command : chmod
Syntax : chmod 777 filename
Explanation : This command gives the corresponding permission to user, group
and other.
END
2(A) Basic Shell Programming
1. Defining Variables in a Script
--------------------------------
#!/bin/bash
name="John"
age=25
echo "Name: $name"
echo "Age: $age"


2. Display User Input
---------------------
#!/bin/bash
echo "Enter your name:"
read user_name
echo "Hello, $user_name!"


3. Concatenating Multiple Variables
-----------------------------------
#!/bin/bash
first_name="John"
last_name="Doe"
full_name="$first_name $last_name"
echo "Full Name: $full_name"


4. Passing Values to Variables as Command Line Arguments
--------------------------------------------------------
#!/bin/bash
# Usage: ./script.sh arg1 arg2
first_argument=$1
second_argument=$2
echo "First Argument: $first_argument"
echo "Second Argument: $second_argument"


5. Adding Two Numbers
---------------------
#!/bin/bash
echo "Enter first number:"
read num1
echo "Enter second number:"
read num2
sum=$((num1 + num2))
echo "Sum: $sum"


6. Division of Two Numbers
--------------------------
#!/bin/bash
echo "Enter dividend:"
read dividend
echo "Enter divisor:"
read divisor
quotient=$((dividend / divisor))
echo "Quotient: $quotient"


7. Calculating the Remainder of a Division
------------------------------------------
#!/bin/bash
echo "Enter dividend:"
read dividend
echo "Enter divisor:"
read divisor
remainder=$((dividend % divisor))
echo "Remainder: $remainder"


8. Check If a Number is Even or Odd
-----------------------------------
#!/bin/bash
echo "Enter a number:"
read number
if ((number % 2 == 0)); then
    echo "$number is Even"
else
    echo "$number is Odd"
fi


9. Perform an Arithmetic Operation Based on User Input
------------------------------------------------------
#!/bin/bash
echo "Enter two numbers:"
read num1 num2
echo "Choose operation (+ - * /):"
read op
case $op in
    +) result=$((num1 + num2)) ;;
    -) result=$((num1 - num2)) ;;
    '*') result=$((num1 * num2)) ;;
    /) result=$((num1 / num2)) ;;
    *) echo "Invalid operation" ; exit 1 ;;
esac
echo "Result: $result"


10. Check if a Given Number is Positive or Negative
---------------------------------------------------
#!/bin/bash
echo "Enter a number:"
read number
if ((number > 0)); then
    echo "$number is Positive"
elif ((number < 0)); then
    echo "$number is Negative"
else
    echo "The number is Zero"
fi
END

2(B) Shell Scripting

1. To Find Whether a Given Voter is Eligible to Vote
----------------------------------------------------
#!/bin/bash
echo "Enter your age:"
read age
if ((age >= 18)); then
    echo "You are eligible to vote."
else
    echo "You are not eligible to vote."
fi


2. To Find the Grade of a Student Using Multiple if
---------------------------------------------------
#!/bin/bash
echo "Enter the marks:"
read marks
if ((marks > 90)); then
    grade="O"
elif ((marks >= 80)); then
    grade="A+"
elif ((marks >= 70)); then
    grade="A"
elif ((marks >= 60)); then
    grade="B+"
elif ((marks >= 50)); then
    grade="B"
elif ((marks >= 45)); then
    grade="C"
else
    grade="U"
fi
echo "Grade: $grade"


3. To Find Whether the Given Year is a Leap Year or Not
-------------------------------------------------------
#!/bin/bash
echo "Enter a year:"
read year
if ((year % 4 == 0 && year % 100 != 0)) || ((year % 400 == 0)); then
    echo "$year is a leap year."
else
    echo "$year is not a leap year."
fi


4. To Find the Factorial of a Given Number Using While and For Loop
-------------------------------------------------------------------
#!/bin/bash
echo "Enter a number:"
read num
factorial=1
for ((i=1; i<=num; i++)); do
    factorial=$((factorial * i))
done
echo "Factorial of $num is $factorial"


5. To Find the Fibonacci Series up to N Terms Using While Loop
--------------------------------------------------------------
#!/bin/bash
echo "Enter the number of terms:"
read n
a=0
b=1
count=0
echo "Fibonacci Series:"
while ((count < n)); do
    echo -n "$a "
    fn=$((a + b))
    a=$b
    b=$fn
    count=$((count + 1))
done
echo ""


6. To Find the Greatest of Three Numbers Using if elif...if
-----------------------------------------------------------
#!/bin/bash
echo "Enter three numbers:"
read num1 num2 num3
if ((num1 >= num2 && num1 >= num3)); then
    echo "$num1 is the greatest."
elif ((num2 >= num1 && num2 >= num3)); then
    echo "$num2 is the greatest."
else
    echo "$num3 is the greatest."
fi


7. To Print Even Numbers From 1 to 10
-------------------------------------
#!/bin/bash
for ((i=1; i<=10; i++)); do
    if ((i % 2 == 0)); then
        echo "$i"
    fi
done


8. To Print the Multiplication Table of a Number
-----------------------------------------------
#!/bin/bash
echo "Enter a number:"
read num
for ((i=1; i<=10; i++)); do
    echo "$num * $i = $((num * i))"
done


9. To Calculate the Sum of Digits of a Given Number
---------------------------------------------------
#!/bin/bash
echo "Enter a number:"
read num
sum=0
while ((num > 0)); do
    digit=$((num % 10))
    sum=$((sum + digit))
    num=$((num / 10))
done
echo "Sum of digits: $sum"


10. To Demonstrate Switch Case – Perform a Logical Operation Based on User Input
--------------------------------------------------------------------------------
#!/bin/bash
echo "Enter two numbers:"
read num1 num2
echo "Choose an operation (+ - * /):"
read op
case $op in
    +) echo "Result: $((num1 + num2))" ;;
    -) echo "Result: $((num1 - num2))" ;;
    '*') echo "Result: $((num1 * num2))" ;;
    /) echo "Result: $((num1 / num2))" ;;
    *) echo "Invalid operation" ;;
esac
END
Implementation Of Unix System Calls

1A
ALGORITHM:
Step 1: Start the program.
Step 2: Declare the variables pid and child id.
Step 3: Get the child id value using system call fork().
Step 4: If child id value is greater than zero then print as “i am in the parent process”.
Step 5: If child id! = 0 then using getpid() system call get the process id.
Step 6: Print “i am in the parent process” and print the process id.
Step 7: If child id! = 0 then using getppid() system call get the parent process id.
Step 8: Print “i am in the parent process” and print the parent process id.
Step 9: Else If child id value is less than zero then print as “i am in the child process”.
Step 10: If child id! = 0 then using getpid() system call get the process id.
Step 11: Print “i am in the child process” and print the process id.
Step 12: If child id! = 0 then using getppid() system call get the parent process id.
Step 13: Print “i am in the child process” and print the parent process id.
Step 14: Stop the program.

PROGRAM :

#include<stdio.h>
#include <unistd.h>
#include<sys/types.h>
int main()
{
    pid_t id,childid;
    id=getpid();
    if((childid=fork())>0)
    {
        printf("\n i am in the parent process %d",id);
        printf("\n i am in the parent process %d",getpid());
        printf("\n i am in the parent process %d\n",getppid());
    }
    else
    {
        printf("\n i am in child process %d",id);
        printf("\n i am in the child process %d",getpid());
        printf("\n i am in the child process %d",getppid());
    }
}
--------------------------------------------------------------

1B
ALGORITHM:
Step 1: Start the program.
Step 2: Declare the variables pid and i as integers.
Step 3: Get the child id value using the system call fork ().
Step 4: If child id value is less than zero then print “fork failed”.
Step 5: Else if child id value is equal to zero, it is the id value of the child and then start the child
process to execute and perform Steps 7 & 8.
Step 6: Else perform Step 9.
Step 7: Use a for loop for almost five child processes to be called.
Step 8: After execution of the for loop then print “child process ends”.
Step 9: Execute the system call wait ( ) to make the parent to wait for the child process to get over.
Step 10: Once the child processes are terminated, the parent terminates and hence prints “Parent
process ends”.
Step 11: After both the parent and the child processes get terminated it execute the wait ( ) system
call to permanently get deleted from the OS.
Step 12: Stop the program.

PROGRAM:
1.B.1 SOURCE CODE:
#include<stdio.h>
#include<unistd.h>
int main( )
{
    pid_t i, pid;
    pid=fork( );
    if(pid== -1)
    {
        printf("fork failed");
        exit(0);
    }
    else if(pid==0)
    {
        printf("\n Child process starts");
        for(i=0; i<5; i++)
        {
            printf("\n Child process %d is called", i);
        }
        printf("\n Child process ends");
    }
    else
    {
        wait(0);
        printf("\n Parent process ends");
    }
    exit(0);
}

1.B.2 
WAIT() AND EXIT() SYSTEM CALLS

SOURCE CODE:
#include <stdlib.h>
#include <errno.h>
#include<stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
main()
{
    pid_t pid;
    int rv;
    switch(pid=fork())
    {
        case -1:
            perror("fork");
            exit(1);
        case 0:
            printf("\n CHILD: This is the child process!\n");
            fflush(stdout);
            printf("\n CHILD: My PID is %d\n", getpid());
            printf("\n CHILD: My parent's PID is %d\n",getppid());
            printf("\n CHILD: Enter my exit status (make it small):\n ");
            printf("\n CHILD: I'm outta here!\n");
            scanf(" %d", &rv);
            exit(rv);
        default:
            printf("\nPARENT: This is the parent process!\n");
            printf("\nPARENT: My PID is %d\n", getpid());
            fflush(stdout);
            wait(&rv);
            fflush(stdout);
            printf("\nPARENT: My child's PID is %d\n", pid);
            printf("\nPARENT: I'm now waiting for my child to exit()...\n");
            fflush(stdout);
            printf("\nPARENT: My child's exit status is:
            %d\n",WEXITSTATUS(rv));
            printf("\nPARENT: I'm outta here!\n");

    }
}
--------------------------------------------------------------

1. C) EXECL SYSTEM CALL

ALGORITHM
Step 1: Start the program.
Step 2: Include the necessary header files.
Step 3: Print execution of exec system call for the ls Unix command.
Step 4: Execute the execl function using the appropriate syntax for the Unix commands ls
and echo.
Step 5: The list of all files and directories of the system is displayed.
Step 6: Stop the program.
PROGRAM :
SOURCE CODE:
/* execl system call */
#include<sys/types.h>
#include<unistd.h>
#include<stdio.h>
main()
{
    printf(“Before execl \n”);
    execl(“/bin/ls”,”ls”,(char*)0);
    execl("/bin/sh", "sh", "-c", "echo hello", NULL);
    printf(“After Execl\n”);
}
END
CPU Scheduling Algorithms
1.A) Write C program to simulate FCFS CPU scheduling algorithm.

ALGORITHM:
Step 1: Start the program.
Step 2: Create the number of process.
Step 3: Get the ID and Service time for each process.
Step 4: Initially, Waiting time of first process is zero and Total time for the first process is the
starting time of that process.
Step 5: Calculate the Total time and Processing time for the remaining processes.
Step 6: Waiting time of one process is the Total time of the previous process.
Step 7: Total time of process is calculated by adding Waiting time and Service time.
Step 8: Total waiting time is calculated by adding the waiting time for lack process.
Step 9: Total turn around time is calculated by adding all total time of each process.
Step 10: Calculate Average waiting time by dividing the total waiting time by total number of
process.
Step 11: Calculate Average turn around time by dividing the total time by the number of process.
Step 12: Display the result.
Step 13: Stop the program.

SOURCE CODE:

#include <stdio.h>

int main() {
    char pn[10][10];
    int arr[10], bur[10], star[10], finish[10], tat[10], wt[10], i, n;
    int totwt = 0, tottat = 0;
    float avgwt, avgtat;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    for(i = 0; i < n; i++) {
        printf("Enter the Process Name, Arrival Time & Burst Time: ");
        scanf("%s %d %d", pn[i], &arr[i], &bur[i]);
    }

    for(i = 0; i < n; i++) {
        if(i == 0) {
            star[i] = arr[i];   // First process starts at its arrival time
        } else {
            // Start time is the maximum of the previous finish time and current arrival time
            star[i] = (finish[i-1] > arr[i]) ? finish[i-1] : arr[i];
        }
        wt[i] = star[i] - arr[i];         // Waiting time is start time minus arrival time
        finish[i] = star[i] + bur[i];     // Finish time is start time plus burst time
        tat[i] = finish[i] - arr[i];      // Turnaround time is finish time minus arrival time

        totwt += wt[i];   // Accumulate total waiting time
        tottat += tat[i]; // Accumulate total turnaround time
    }

    avgwt = (float)totwt / n;             // Average waiting time
    avgtat = (float)tottat / n;           // Average turnaround time

    printf("\nPName   Arrtime Burtime Start   TAT   Finish");
    for(i = 0; i < n; i++) {
        printf("\n%s\t%6d\t%6d\t%6d\t%6d\t%6d", pn[i], arr[i], bur[i], star[i], tat[i], finish[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avgwt);
    printf("\nAverage Turn Around Time: %.2f\n", avgtat);

    return 0;
}
--------------------------------------------------------------

1.B) Write C program to simulate SJF CPU scheduling algorithm.
ALGORITHM:
Step 1: Start the program.
Step 2: Get the number of processes.
Step 3: Get the id and service time for each process.
Step 4: Initially the waiting time of first short process as 0 and total time of first short is process the
service time of that process.
Step 5: Calculate the total time and waiting time of remaining process.
Step 6: Waiting time of one process is the total time of the previous process.
Step 7: Total time of process is calculated by adding the waiting time and service time of each
process.
Step 8: Total waiting time calculated by adding the waiting time of each process.
Step 9: Total turnaround time calculated by adding all total time of each process.
Step 10: Calculate average waiting time by dividing the total waiting time by total number of
processes.
Step 11: Calculate average turnaround time by dividing the total waiting time by total number of
processes.
Step 12: Display the result.
Step 13: Stop the program.

SOURCE CODE:
/* A program to simulate the SJF CPU scheduling algorithm */
#include <stdio.h>
#include <string.h>

int main() {
    int i = 0, pno[10], bt[10], n, wt[10], temp = 0, j, tt[10];
    float sum = 0.0, at = 0.0;

    printf("\n Enter the number of processes: ");
    scanf("%d", &n);

    printf("\n Enter the burst time of each process:");
    for(i = 0; i < n; i++) {
        printf("\n p%d: ", i);
        scanf("%d", &bt[i]);
        pno[i] = i; // Initialize process numbers
    }

    // Sort processes by burst time using Bubble Sort
    for(i = 0; i < n - 1; i++) {
        for(j = i + 1; j < n; j++) {
            if(bt[i] > bt[j]) {
                // Swap burst times
                temp = bt[i];
                bt[i] = bt[j];
                bt[j] = temp;

                // Swap process numbers
                temp = pno[i];
                pno[i] = pno[j];
                pno[j] = temp;
            }
        }
    }

    // Initialize waiting time for the first process
    wt[0] = 0;

    // Calculate waiting times and total waiting time
    for(i = 1; i < n; i++) {
        wt[i] = bt[i - 1] + wt[i - 1];
        sum += wt[i];
    }

    printf("\nProcess No\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for(i = 0; i < n; i++) {
        tt[i] = bt[i] + wt[i]; // Turnaround time = burst time + waiting time
        at += tt[i];           // Accumulate total turnaround time
        printf("\n p%d\t\t%d\t\t%d\t\t%d", pno[i], bt[i], wt[i], tt[i]);
    }

    printf("\n\nAverage Waiting Time: %.2f", sum / n);
    printf("\nAverage Turnaround Time: %.2f\n", at / n);

    return 0;
}
--------------------------------------------------------------

1.C) Write C program to simulate Round Robin CPU scheduling algorithm.
ALGORITHM:
Step 1: Start the program.
Step 2: Initialize all the structure elements.
Step 3: Receive inputs from the user to fill process id, burst time and arrival time.
Step 4: Calculate the waiting time for all the process id.
i. The waiting time for first instance of a process is calculated as: a[i].waittime=count +
a[i].arrivt.
ii. The waiting time for the rest of the instances of the process is calculated as:
a) If the time quantum is greater than the remaining burst time then waiting time is
calculated as: a[i].waittime=count + tq.
b) Else if the time quantum is greater than the remaining burst time then waiting time is
calculated as: a[i].waittime=count - remaining burst time
Step 5: Calculate the average waiting time and average turnaround time
Step 6: Print the results of the step 4.
Step 7: Stop the program.

SOURCE CODE:

#include <stdio.h>

struct process {
    int burst, wait, comp, f;
} p[20] = {0, 0};

int main() {
    int n, i, j, totalwait = 0, totalturn = 0, quantum, flag = 1, time = 0;
    
    printf("\nEnter the number of processes: ");
    scanf("%d", &n);

    printf("\nEnter the quantum time (in ms): ");
    scanf("%d", &quantum);

    for (i = 0; i < n; i++) {
        printf("Enter the burst time (in ms) for Process #%2d: ", i + 1);
        scanf("%d", &p[i].burst);
        p[i].f = 1;  
    }

    printf("\nOrder of Execution\n");
    printf("\nProcess    Starting Time    Ending Time    Remaining Time\n");

    while (flag == 1) {
        flag = 0;  
        
        for (i = 0; i < n; i++) {
            if (p[i].f == 1) {
                flag = 1;  
                int remaining_burst = p[i].burst - p[i].comp;

                if (remaining_burst > quantum) {
                    printf("\nProcess #%2d   %-10d      %-10d      %-10d", 
                           i + 1, time, time + quantum, remaining_burst - quantum);
                    time += quantum;
                    p[i].comp += quantum;
                } else {
                    printf("\nProcess #%2d   %-10d      %-10d      %-10d", 
                           i + 1, time, time + remaining_burst, 0);
                    time += remaining_burst;
                    p[i].comp = p[i].burst;  // Mark as fully executed
                    p[i].f = 0;  // Set flag to 0 to indicate completion
                    p[i].wait = time - p[i].burst;  // Calculate waiting time
                }
            }
        }
    }

    printf("\n\nProcess   Waiting Time    TurnAround Time\n");
    for (i = 0; i < n; i++) {
        int turnaround_time = p[i].wait + p[i].burst;
        printf("\nProcess #%2d     %-15d  %-15d", i + 1, p[i].wait, turnaround_time);
        totalwait += p[i].wait;
        totalturn += turnaround_time;
    }

    printf("\n\nAverage\n------------------");
    printf("\nWaiting Time: %.2f ms", totalwait / (float)n);
    printf("\nTurnAround Time: %.2f ms\n\n", totalturn / (float)n);

    return 0;
}
END
Producer-Consumer Problem Using Semaphores

Initialization:
1. Start the process.
2. Initialize semaphores:
   - mutex = 1 (for mutual exclusion of the shared buffer).
   - empty = N (number of empty slots in the buffer, initially equal to the buffer size).
   - full = 0 (number of filled slots in the buffer, initially 0).
3. Set buffer pointers:
   - in = 0 (the index where the producer will insert the next item).
   - out = 0 (the index from which the consumer will remove the next item).

Producer Process:
4. Continuously produce items:
   - For each item:
     1. Wait for space in the buffer using wait(empty).
     2. Lock the buffer using wait(mutex) to ensure mutual exclusion.
     3. Insert the item into the buffer at the in position.
     4. Update the in pointer: in = (in + 1) % N.
     5. Release the mutex using signal(mutex).
     6. Indicate that an item is available using signal(full).

Consumer Process:
5. Continuously consume items:
   - For each item:
     1. Wait for a filled slot using wait(full).
     2. Lock the buffer using wait(mutex) to ensure mutual exclusion.
     3. Remove the item from the buffer at the out position.
     4. Update the out pointer: out = (out + 1) % N.
     5. Release the mutex using signal(mutex).
     6. Indicate that an empty slot is available using signal(empty).

6. Stop the process.

SOURCE CODE:

#include <stdio.h>
#include <stdlib.h>

int mutex = 1;
int full = 0;
int empty = 3;
int x = 0;

void producer();
void consumer();
int wait(int);
int signal(int);

int main() {
    int n;
    printf("\n1. Producer\n2. Consumer\n3. Exit\n");
    
    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &n);

        switch (n) {
            case 1:
                if ((mutex == 1) && (empty != 0)) {
                    producer();
                } else {
                    printf("Buffer is full!!");
                }
                break;

            case 2:
                if ((mutex == 1) && (full != 0)) {
                    consumer();
                } else {
                    printf("Buffer is empty!!");
                }
                break;

            case 3:
                exit(0);
                break;

            default:
                printf("Invalid choice, please try again.");
        }
    }

    return 0;
}

int wait(int s) {
    return (--s);
}

int signal(int s) {
    return (++s);
}

void producer() {
    mutex = wait(mutex);
    full = signal(full);
    empty = wait(empty);
    x++;
    printf("\nProducer produces the item %d", x);
    mutex = signal(mutex);
}

void consumer() {
    mutex = wait(mutex);
    full = wait(full);
    empty = signal(empty);
    printf("\nConsumer consumes item %d", x);
    x--;
    mutex = signal(mutex);
}
--------------------------------------------------------------

ii) Implementation of Dining Philosopher’s Problem to demonstrate Process
Synchronization

ALGORITHM:
1. Start the process.
2. Initialize the semaphores for each fork to 1 (indicating that they are available).
3. Initialize a binary semaphore (mutex) to 1 to ensure that only one philosopher can
attempt to pick up a fork at a time.
4. For each philosopher process, create a separate thread that executes the following
code:
• While true:

o Think for a random amount of time.
o Acquire the mutex semaphore to ensure that only one philosopher can
attempt to pick up a fork at a time.
o Attempt to acquire the semaphore for the fork to the left.
• If successful, attempt to acquire the semaphore for the fork to the right.
• If both forks are acquired successfully, eat for a random amount of time and then
release both semaphores.
• If not successful in acquiring both forks, release the semaphore for the fork to the left
(if acquired) and then release the mutex semaphore and go back to thinking.
5. Run the philosopher threads concurrently.
6. Stop the process.

#include <stdio.h>
#define n 4

int compltedPhilo = 0;
int i;

struct fork {
    int taken;
} ForkAvil[n];

struct philosp {
    int left;
    int right;
} Philostatus[n];

void goForDinner(int philID) {
    if (Philostatus[philID].left == 10 && Philostatus[philID].right == 10) {
        printf("Philosopher %d completed his dinner\n", philID + 1);
    } else if (Philostatus[philID].left == 1 && Philostatus[philID].right == 1) {
        printf("Philosopher %d completed his dinner\n", philID + 1);
        Philostatus[philID].left = Philostatus[philID].right = 10;

        int otherFork = philID - 1;
        if (otherFork == -1)
            otherFork = n - 1;

        ForkAvil[philID].taken = ForkAvil[otherFork].taken = 0;
        printf("Philosopher %d released fork %d and fork %d\n", philID + 1, philID + 1, otherFork + 1);
        compltedPhilo++;
    } else if (Philostatus[philID].left == 1 && Philostatus[philID].right == 0) {
        if (philID == n - 1) {
            if (ForkAvil[philID].taken == 0) {
                ForkAvil[philID].taken = Philostatus[philID].right = 1;
                printf("Fork %d taken by philosopher %d\n", philID + 1, philID + 1);
            } else {
                printf("Philosopher %d is waiting for fork %d\n", philID + 1, philID + 1);
            }
        } else {
            int dupphilID = philID;
            philID -= 1;
            if (philID == -1)
                philID = n - 1;
            if (ForkAvil[philID].taken == 0) {
                ForkAvil[philID].taken = Philostatus[dupphilID].right = 1;
                printf("Fork %d taken by Philosopher %d\n", philID + 1, dupphilID + 1);
            } else {
                printf("Philosopher %d is waiting for Fork %d\n", dupphilID + 1, philID + 1);
            }
        }
    } else if (Philostatus[philID].left == 0) {
        if (philID == n - 1) {
            if (ForkAvil[philID - 1].taken == 0) {
                ForkAvil[philID - 1].taken = Philostatus[philID].left = 1;
                printf("Fork %d taken by philosopher %d\n", philID, philID + 1);
            } else {
                printf("Philosopher %d is waiting for fork %d\n", philID + 1, philID);
            }
        } else {
            if (ForkAvil[philID].taken == 0) {
                ForkAvil[philID].taken = Philostatus[philID].left = 1;
                printf("Fork %d taken by Philosopher %d\n", philID + 1, philID + 1);
            } else {
                printf("Philosopher %d is waiting for Fork %d\n", philID + 1, philID + 1);
            }
        }
    }
}

int main() {
    for (i = 0; i < n; i++)
        ForkAvil[i].taken = Philostatus[i].left = Philostatus[i].right = 0;

    while (compltedPhilo < n) {
        for (i = 0; i < n; i++)
            goForDinner(i);

        printf("\nTill now number of philosophers who have completed dinner: %d\n\n", compltedPhilo);
    }
    return 0;
}
END
Banker’s Algorithm

ALGORITHM:

1. Start the Process
   - Let n be the number of processes.
   - Let m be the number of resource types.
   - Define the following data structures:
     - Available: Vector of length m representing the available resources.
     - Max: An n x m matrix that represents the maximum demand of each process.
     - Allocation: An n x m matrix that represents the number of resources allocated to each process.
     - Need: An n x m matrix that represents the remaining resources needed by each process.

2. Safety Algorithm
   - Initialize:
     - Work = Available (a vector of length m)
     - Finish = [False, False, ..., False] (a boolean array of length n indicating whether each process is finished)
   - Repeat until a safe sequence is found:
     - Find an index i such that:
       - Finish[i] = False (the process has not finished)
       - Need[i] <= Work (the process can be completed with the available resources)
     - If no such i exists, proceed to step 4.
     - For the selected process P[i]:
       - Set Work = Work + Allocation[i] (add the allocated resources of P[i] to Work)
       - Set Finish[i] = True (mark process P[i] as finished)
       - Go back to step 2.
     - If Finish[i] = True for all processes i, then the system is in a safe state.

3. Resource-Request Algorithm
   - Let Request be the request vector for process P[i].
   - When a request is made by process P[i], do the following:
     - If Request[i] > Need[i], raise an error (process P[i] has exceeded its maximum claim).
     - If Request[i] > Available, process P[i] must wait (resources are not available).
     - If the request is valid, update the resources:
       - Set Available = Available - Request[i]
       - Set Allocation = Allocation + Request[i]
       - Set Need = Need - Request[i]
   - Stop the process.

PROGRAM:

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int n, m, i, j; // n = number of processes, m = number of resources
int all[10][10], max[10][10], need[10][10], avail[10], work[10], req[10];

int count = 0;

struct process {
    char process[10]; // to name the process, e.g., process = 0 implies process 0 = P0
    int flag; // used to check the safe sequence
} p[10];

void input() {
    printf("\nEnter total number of processes: ");
    scanf("%d", &n);

    for (i = 0; i < n; i++) {
        printf("\nProcess: ");
        scanf("%s", p[i].process);
    }

    printf("\nEnter the number of resources: ");
    scanf("%d", &m);

    printf("\nEnter allocation matrix: ");
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            scanf("%d", &all[i][j]);
        }
    }

    printf("\nEnter max matrix: ");
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            scanf("%d", &max[i][j]);
        }
    }

    printf("\nNeed matrix: ");
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            need[i][j] = max[i][j] - all[i][j];
            printf("%d ", need[i][j]);
        }
        printf("\n");
    }

    printf("\nEnter Available: ");
    for (i = 0; i < m; i++) {
        scanf("%d", &avail[i]);
    }
}

void safeseq() {
    int sseq[10], ss = 0, chk = 0, chki = 0;

    for (j = 0; j < m; j++) {
        work[j] = avail[j]; // initialize work = available
    }

    for (i = 0; i < n; i++) {
        p[i].flag = 0; // initialize finish[i] = false for i = 0, 1, 2, ...
    }

    while (count != n) {
        for (i = 0; i < n; i++) {
            chk = 0;
            for (j = 0; j < m; j++) {
                if (p[i].flag == 0) {
                    if (need[i][j] <= work[j]) {
                        chk++;
                    }
                }
            }

            if (chk == m) {
                for (j = 0; j < m; j++) {
                    work[j] = work[j] + all[i][j];
                    p[i].flag = 1;
                }
                sseq[ss] = i;
                ss++;
                count++;
            }
        }
    }

    for (i = 0; i < n; i++) {
        if (p[i].flag == 1) {
            chki++;
        }
    }

    if (chki >= n) {
        printf("\nSystem is in a safe state.\nSafe sequence: ");
        for (i = 0; i < n; i++) {
            printf("%d\t", sseq[i]);
        }
    } else {
        printf("\nSystem is not safe.");
    }
}

void request() {
    int processreq;
    printf("\nEnter the process that is requesting: ");
    scanf("%d", &processreq);

    printf("\nEnter the requested array: ");
    for (i = 0; i < m; i++) {
        scanf("%d", &req[i]);
    }

    for (j = 0; j < m; j++) {
        if (req[j] <= need[processreq][j]) {
            if (req[j] <= avail[j]) {
                avail[j] = avail[j] - req[j];
                all[processreq][j] = all[processreq][j] + req[j];
                need[processreq][j] = need[processreq][j] - req[j];
                printf("Avail: %d", avail[j]);
            }
            printf("\tNeed: %d\n", need[processreq][j]);
        } else {
            printf("\nProcess is not in a safe state, and hence the request cannot be granted.");
            exit(0);
        }
    }

    printf("\nRequest can be granted.");
}

void print() {
    printf("Number of processes = %d\n", n);
    printf("Number of resources = %d\n", m);
    printf("PID\tMax\tAllocated\tNeed\n");

    for (i = 0; i < n; i++) {
        printf("%d\t", i);
        for (j = 0; j < m; j++) {
            printf(" %d ", max[i][j]);
        }
        printf("\t");
        for (j = 0; j < m; j++) {
            printf(" %d ", all[i][j]);
        }
        printf("\t");
        for (j = 0; j < m; j++) {
            printf(" %d ", need[i][j]);
        }
        printf("\t");
    }

    printf("\nAvailable: ");
    for (i = 0; i < m; i++) {
        printf("%d ", avail[i]);
    }
}

int main() {
    int ch;
    do {
        printf("\nMenu:\n");
        printf("1. Input\n");
        printf("2. Safe Sequence\n");
        printf("3. Request\n");
        printf("4. Print\n");
        printf("5. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &ch);

        switch (ch) {
            case 1:
                input();
                break;
            case 2:
                safeseq();
                break;
            case 3:
                request();
                break;
            case 4:
                print();
                break;
            case 5:
                break;
        }
    } while (ch != 5);

    return 0;
}
END
Memory Allocation And Management

A) FIRST FIT ALGORITHM:
ALGORITHM:
1. Start the process.
2. Get no. of Processes and no. of blocks.
3. After that get the size of each block and process requests.
4. Now allocate processes
if(block size &gt;= process size)
//allocate the process
else
//move on to next block

5. Display the processes with the blocks that are allocated to a respective process.
6. Stop the Process.

PROGRAM:

#include <stdio.h>

void main() {
    int bsize[10], psize[10], bno, pno, flags[10], allocation[10], i, j;

    // Initialize flags and allocation arrays
    for (i = 0; i < 10; i++) {
        flags[i] = 0;
        allocation[i] = -1;
    }

    // Input number of blocks and their sizes
    printf("Enter no. of blocks: ");
    scanf("%d", &bno);

    printf("\nEnter size of each block: ");
    for (i = 0; i < bno; i++)
        scanf("%d", &bsize[i]);

    // Input number of processes and their sizes
    printf("\nEnter no. of processes: ");
    scanf("%d", &pno);

    printf("\nEnter size of each process: ");
    for (i = 0; i < pno; i++)
        scanf("%d", &psize[i]);

    // Allocation as per first fit
    for (i = 0; i < pno; i++) {
        for (j = 0; j < bno; j++) {
            if (flags[j] == 0 && bsize[j] >= psize[i]) {
                allocation[j] = i;
                flags[j] = 1;
                break;
            }
        }
    }

    // Display allocation details
    printf("\nBlock no.\tsize\t\tprocess no.\t\tsize");
    for (i = 0; i < bno; i++) {
        printf("\n%d\t\t%d\t\t", i + 1, bsize[i]);
        if (flags[i] == 1)
            printf("%d\t\t\t%d", allocation[i] + 1, psize[allocation[i]]);
        else
            printf("Not allocated");
    }
}
--------------------------------------------------------------

B) BEST FIT ALGORITHM:
ALGORITHM:
1. Start the process.
2. Get no. of Processes and no. of blocks.
3. After that get the size of each block and process requests.
4. Then select the best memory block that can be allocated using the above definition.
5. Display the processes with the blocks that are allocated to a respective process.
6. Value of Fragmentation is optional to display to keep track of wasted memory.
7. Stop the process.

PROGRAM:

#include <stdio.h>

void main() {
    int fragment[20], b[20], p[20], i, j, nb, np, temp, lowest = 9999;

    static int barray[20], parray[20];

    // Print title
    printf("\n\t\t\tMemory Management Scheme - Best Fit");

    // Input number of blocks
    printf("\nEnter the number of blocks: ");
    scanf("%d", &nb);

    // Input number of processes
    printf("Enter the number of processes: ");
    scanf("%d", &np);

    // Input block sizes
    printf("\nEnter the size of the blocks:-\n");
    for (i = 1; i <= nb; i++) {
        printf("Block no.%d: ", i);
        scanf("%d", &b[i]);
    }

    // Input process sizes
    printf("\nEnter the size of the processes :-\n");
    for (i = 1; i <= np; i++) {
        printf("Process no.%d: ", i);
        scanf("%d", &p[i]);
    }

    // Best fit allocation
    for (i = 1; i <= np; i++) {
        lowest = 9999; // Reset lowest for each process

        for (j = 1; j <= nb; j++) {
            if (barray[j] != 1) { // If block is not allocated
                temp = b[j] - p[i]; // Calculate the fragment
                if (temp >= 0 && lowest > temp) { // Find the best fit
                    parray[i] = j; // Allocate block to process
                    lowest = temp; // Update the lowest fragment
                }
            }
        }

        fragment[i] = lowest; // Store the fragment size
        barray[parray[i]] = 1; // Mark the block as allocated
    }

    // Display allocation details
    printf("\nProcess_no\tProcess_size\tBlock_no\tBlock_size\tFragment");
    for (i = 1; i <= np && parray[i] != 0; i++) {
        printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d", i, p[i], parray[i], b[parray[i]], fragment[i]);
    }
}
--------------------------------------------------------------


C) WORST FIT ALGORITHM:
ALGORITHM:
1. Start the process.
2. Initialize memory blocks and processes with sizes.
3. Traverse the memory blocks to find the worst fit block (largest block) that can
accommodate the process.
4. Allocate the process to the worst fit block.
5. Update the block size by subtracting the process size from the block size.
6. Repeat this for all processes.
7. Start the process.

PROGRAM:

#include <stdio.h>

void worstFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i < n; i++) {
        allocation[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        int worstIdx = -1;
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx]) {
                    worstIdx = j;
                }
            }
        }
        
        if (worstIdx != -1) {
            allocation[i] = worstIdx;
            blockSize[worstIdx] -= processSize[i];
        }
    }

    printf("\nProcess No.\tProcess Size\tBlock No.\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t\t%d\t\t", i + 1, processSize[i]);
        if (allocation[i] != -1) {
            printf("%d\n", allocation[i] + 1);
        } else {
            printf("Not Allocated\n");
        }
    }
}

int main() {
    int blockSize[] = {100, 500, 200, 300, 600};
    int processSize[] = {212, 417, 112, 426};
    int m = sizeof(blockSize) / sizeof(blockSize[0]);
    int n = sizeof(processSize) / sizeof(processSize[0]);

    worstFit(blockSize, m, processSize, n);

    return 0;
}
END
Page Replacement Algorithms

A) FIRST IN FIRST OUT
ALGORITHM:
1. Start the process
2. Read number of pages n
3. Read number of pages no
4. Read page numbers into an array a[i]
5. Initialize avail[i]=0 .to check page hit
6. Replace the page with circular queue, while re-placing check page availability in
the frame. Place avail[i]=1 if page is placed in the frame
7. Count page faults
8. Print the results.
9. Stop the process.

PROGRAM:

#include <stdio.h>

int fr[3];

void display() {
    int i;
    printf("\n");
    for(i = 0; i < 3; i++)
        printf("%d\t", fr[i]);
}

void main() {
    int i, j, page[12] = {2, 3, 2, 1, 5, 2, 4, 5, 3, 2, 5, 2};
    int flag1 = 0, flag2 = 0, pf = 0, frsize = 3, top = 0;

    for(i = 0; i < 3; i++) {
        fr[i] = -1;
    }

    for(j = 0; j < 12; j++) {
        flag1 = 0;
        flag2 = 0;

        for(i = 0; i < 12; i++) {
            if(fr[i] == page[j]) {
                flag1 = 1;
                flag2 = 1;
                break;
            }
        }

        if(flag1 == 0) {
            for(i = 0; i < frsize; i++) {
                if(fr[i] == -1) {
                    fr[i] = page[j];
                    flag2 = 1;
                    break;
                }
            }
        }

        if(flag2 == 0) {
            fr[top] = page[j];
            top++;
            pf++;

            if(top >= frsize)
                top = 0;
        }

        display();
    }

    printf("Number of page faults: %d", pf + frsize);
}
--------------------------------------------------------------

B) LEAST RECENTLY USED
AIM:
To implement LRU page replacement technique.
ALGORITHM:
1. Start the process
2. Declare the size
3. Get the number of pages to be inserted
4. Get the value
5. Declare counter and stack
6. Select the least recently used page by counter value
7. Stack them according the selection.
8. Display the values
9. Stop the process

PROGRAM:

#include <stdio.h>

int fr[3];

void display() {
    int i;
    printf("\n");
    for(i = 0; i < 3; i++) {
        printf("\t%d", fr[i]);
    }
}

void main() {
    int p[12] = {2, 3, 2, 1, 5, 2, 4, 5, 3, 2, 5, 2};
    int i, j, fs[3];
    int index, k, l, flag1 = 0, flag2 = 0, pf = 0, frsize = 3;

    for(i = 0; i < 3; i++) {
        fr[i] = -1;
    }

    for(j = 0; j < 12; j++) {
        flag1 = 0;
        flag2 = 0;

        for(i = 0; i < 3; i++) {
            if(fr[i] == p[j]) {
                flag1 = 1;
                flag2 = 1;
                break;
            }
        }

        if(flag1 == 0) {
            for(i = 0; i < 3; i++) {
                if(fr[i] == -1) {
                    fr[i] = p[j];
                    flag2 = 1;
                    break;
                }
            }
        }

        if(flag2 == 0) {
            for(i = 0; i < 3; i++) {
                fs[i] = 0;
            }

            for(k = j - 1, l = 1; l <= frsize - 1; l++, k--) {
                for(i = 0; i < 3; i++) {
                    if(fr[i] == p[k]) {
                        fs[i] = 1;
                    }
                }
            }

            for(i = 0; i < 3; i++) {
                if(fs[i] == 0) {
                    index = i;
                }
            }

            fr[index] = p[j];
            pf++;
        }

        display();
    }

    printf("\nNo of page faults: %d", pf + frsize);
}
--------------------------------------------------------------

C) OPTIMAL PAGE REPLACEMENT ALGORITHM
AIM:
To implement optimal page replacement technique.
ALGORTHIM:
1. Start Program
2. Read Number of Pages and Frames
3.Read Each Page Value
4. Search For Page in the Frames
5.If Not Available Allocate Free Frame
6. If No Frames is free, replace the page with the page that is Leastly Used
7.Print Page Number of Page Faults
8.Stop process.

PROGRAM:

#include <stdio.h>

int fr[3], n, m;

void display();

void main() {
    int i, j, page[20], fs[10];
    int max, found = 0, lg[3], index, k, l, flag1 = 0, flag2 = 0, pf = 0;
    float pr;

    printf("Enter length of the reference string: ");
    scanf("%d", &n);

    printf("Enter the reference string: ");
    for(i = 0; i < n; i++) {
        scanf("%d", &page[i]);
    }

    printf("Enter no of frames: ");
    scanf("%d", &m);

    for(i = 0; i < m; i++) {
        fr[i] = -1; 
    }
    
    pf = m;  // Initially, there are `m` page faults when the frames are filled.

    for(j = 0; j < n; j++) {
        flag1 = 0;
        flag2 = 0;

        for(i = 0; i < m; i++) {
            if(fr[i] == page[j]) {
                flag1 = 1; 
                flag2 = 1; 
                break;
            }
        }

        if(flag1 == 0) {
            for(i = 0; i < m; i++) {
                if(fr[i] == -1) {
                    fr[i] = page[j]; 
                    flag2 = 1;
                    break;
                }
            }
        }

        if(flag2 == 0) {
            for(i = 0; i < m; i++) {
                lg[i] = 0;
            }

            for(i = 0; i < m; i++) {
                for(k = j + 1; k <= n; k++) {
                    if(fr[i] == page[k]) {
                        lg[i] = k - j;
                        break;
                    }
                }
            }

            found = 0;
            for(i = 0; i < m; i++) {
                if(lg[i] == 0) {
                    index = i;
                    found = 1;
                    break;
                }
            }

            if(found == 0) {
                max = lg[0];
                index = 0;
                for(i = 0; i < m; i++) {
                    if(max < lg[i]) {
                        max = lg[i];
                        index = i;
                    }
                }
            }

            fr[index] = page[j];
            pf++;
        }

        display();
    }

    printf("Number of page faults: %d\n", pf);
    pr = (float)pf / n * 100;
    printf("Page fault rate = %.2f%% \n", pr);
}

void display() {
    int i;
    for(i = 0; i < m; i++) {
        printf("%d\t", fr[i]);
    }
    printf("\n");
}
