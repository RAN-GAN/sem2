Implementation of Linear search

Question
A librarian is organizing books on a shelf. A student asks for a specific book, but the librarian has no index. She checks each book one by one until she finds the right one. Implement a function to help her search for the book’s position efficiently using linear search.

Input Format
- First line represents Number of elements (n): An integer representing the size of the array.
- Second line contains a list or array containing n elements of any data type (integers, strings, etc.).
- Third line a target element: The value you're searching for within the array.

Output Format
- Print Index of the target element: If the target element is found in the array, the output will be the integer index of its position.
- Print -1 (or any other designated value): If the target element is not found in the array.

Constraints
-100 <= n <= 100

Note
Function name should be int linearSearch(int arr[], int n, int x)

Test Cases
5
4 3 2 6 8
3
Output:
1

5
2 3 6 2 1
10
Output:
-1

2
1 6
6
Output:
1

9
8 7 6 9 5 4 3 2 5
9
Output:
3

1
12
12
Output:
0

2
1 6
6
Output:
1


Answer

import java.util.Scanner;

public class Main {
    public static int linearSearch(int arr[], int n, int x) {
        for (int i = 0; i < n; i++) {
            if (arr[i] == x) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];

        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int x = scanner.nextInt();
        System.out.println(linearSearch(arr, n, x));

        scanner.close();
    }
}

END
Implementation of Binary Search

Question
Given a sorted array of integers and a target value, perform a binary search to find the index of the target in the array. If the target exists, return its index (0-based). If the target does not exist, return -1.

Input Format
- The first line contains an integer n (the size of the array).
- The second line contains n integers (the elements of the array), sorted in non-decreasing order.
- The third line contains the target integer to be searched.

Output Format
- A single integer representing the index of the target in the array or -1 if the target is not found.
- Print "Invalid input" if n is not an integer or is outside the range 1 ≤ n ≤ 10^5, or if the input array is not sorted.

Constraints
1 ≤ n ≤ 10^5
-10^6 ≤ array elements, target ≤ 10^6

Test Cases
5
1 3 5 7 9
5
Output:
2

5
10 30 20 40 50
20
Output:
Invalid input

6
3 7 13 19 28 30
13
Output:
2

6
1 2 3 4 5 6
10
Output:
-1

4
1 2 3 4
abc
Output:
Invalid input

6
3 7 13 19 28 30
13
Output:
2

Answer 

import java.util.Scanner;

public class Main {
    public static int binarySearch(int arr[], int left, int right, int target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid; 
            }
            if (arr[mid] < target) {
                left = mid + 1; 
            } else {
                right = mid - 1; 
            }
        }
        return -1; 
    }

    public static boolean isSorted(int arr[], int n) {
        for (int i = 1; i < n; i++) {
            if (arr[i] < arr[i - 1]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        try {
            int n = scanner.nextInt();
            if (n < 1 || n > 100000) {
                System.out.println("Invalid input");
                return;
            }

            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }

            if (!isSorted(arr, n)) {
                System.out.println("Invalid input");
                return;
            }

            if (!scanner.hasNextInt()) {
                System.out.println("Invalid input");
                return;
            }

            int target = scanner.nextInt();
            System.out.println(binarySearch(arr, 0, n - 1, target));
        } catch (Exception e) {
            System.out.println("Invalid input");
        } finally {
            scanner.close();
        }
    }
}


END
Implementation of Sorting Algorithms

Question
Imagine you have a collection of numbers and need to find the k-th smallest one. To do this, you’ll sort the numbers using Quick Sort, a method that cleverly arranges everything in order. Once sorted, you’ll pick the k-th smallest number from the lineup and return it.

Input Format
- The first line contains an integer n (the size of the array).
- The second line contains n integers (the elements of the array).
- The third line contains an integer k (the position of the element to find, 1-based index).

Output Format
- A single integer representing the k-th smallest element in the array.
- Print "Invalid input" if inputs are non-integer.

Constraints
1 ≤ n ≤ 10^5
1 ≤ k ≤ n
-10^6 ≤ array elements ≤ 10^6

Test Cases
6
3 2 1 5 6 4
2
Output:
2

5
1 2 a 4 5
3
Output:
Invalid input

4
4 2 6 8
3
Output:
6

5
10 15 20 25 30
5
Output:
30

3
1 1 1
2
Output:
1

4
4 2 6 8
3
Output:
6

Answer 

import java.util.Scanner;

public class Main {
    public static void quickSort(int arr[], int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        try {
            int n = scanner.nextInt();
            if (n < 1 || n > 100000) {
                System.out.println("Invalid input");
                return;
            }

            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                if (!scanner.hasNextInt()) {
                    System.out.println("Invalid input");
                    return;
                }
                arr[i] = scanner.nextInt();
            }

            if (!scanner.hasNextInt()) {
                System.out.println("Invalid input");
                return;
            }

            int k = scanner.nextInt();
            if (k < 1 || k > n) {
                System.out.println("Invalid input");
                return;
            }

            quickSort(arr, 0, n - 1);
            System.out.println(arr[k - 1]);

        } catch (Exception e) {
            System.out.println("Invalid input");
        } finally {
            scanner.close();
        }
    }
}


END
Implementation of Greedy Algorithms

Question
A community center hosts events, each needing specific resources. Events overlap, so the manager must pick events carefully, ensuring none clash while using the least resources. The goal is to plan efficiently, keeping the resource usage minimal while accommodating as many non-overlapping events as possible.

Input Format
- An integer n representing the number of activities.
- The next n lines contain three integers representing the start time, end time, and resource requirement of an activity.

Output Format
- Print the start time, end time, and resource requirement of each selected activity.
- Print the total resources allocated in the next line.
- Print "Invalid input", if start time > end time.

Constraints
1 <= n <= 100
0 <= start time, end time <= 10

Test Cases
4
1 3 2
2 5 3
4 6 1
5 7 4

Output:
1 3 2
4 6 1
Total resources: 3

1
2 1 10

Output:
Invalid input

2
1 3 2
4 6 3

Output:
1 3 2
4 6 3
Total resources: 5

3
1 5 4
3 2 5
3 7 6

Output:
Invalid input

5
1 4 3
3 5 2
0 6 6
5 7 1
8 9 2

Output:
1 4 3
5 7 1
8 9 2
Total resources: 6

2
1 3 2
4 6 3

Output:
1 3 2
4 6 3
Total resources: 5

Answer 

import java.util.*;

class Main {
    static void selectEvents(List<int[]> events) {
        events.sort(Comparator.comparingInt(a -> a[1])); // Sort by end time

        List<int[]> selectedEvents = new ArrayList<>();
        int totalResources = 0, lastEndTime = -1;

        for (int[] event : events) {
            int start = event[0], end = event[1], resource = event[2];
            
            if (start > end) {
                System.out.println("Invalid input");
                return;
            }
            
            if (start >= lastEndTime) { // Select non-overlapping events
                selectedEvents.add(event);
                totalResources += resource;
                lastEndTime = end;
            }
        }

        for (int[] event : selectedEvents) {
            System.out.println(event[0] + " " + event[1] + " " + event[2]);
        }
        System.out.println("Total resources: " + totalResources);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<int[]> events = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            int resource = scanner.nextInt();
            events.add(new int[]{start, end, resource});
        }
        scanner.close();
        
        selectEvents(events);
    }
}

END
Implementation of Pattern Searching Algorithms

Question
As a plagiarism detection engineer, you are developing a document similarity checker that scans a document for a copied sentence using the Rabin-Karp algorithm.

Your system should identify and return the starting index of the copied sentence inside the document.

Input Format
- The first line contains a string str1 (document text) representing the document.
- The second line contains a string str2 (copied sentence) that needs to be detected.

Output Format
- A list of integers, where each integer represents the starting index (including space) of the copied sentence in the document.
- Print "Not found" if the copied sentence is not present.
- Print "Invalid input", if the length of str2 > str1

Constraints
1 ≤ Length of document ≤ 10⁶
1 ≤ Length of copied sentence ≤ 10⁵

Test Cases

Test Case 1:
Input:
This is a plagiarism check. Plagiarism is not allowed
Plagiarism

Output:
28

Test Case 2:
Input:
short
this is a very long copied sentence that is longer than the document

Output:
Invalid input

Test Case 3:
Input:
This is an original document with no copied content
Copied sentence

Output:
Not found

Test Case 4:
Input:
copied sentence
sentence

Output:
7

Test Case 5:
Input:
The quick brown fox jumps over the lazy dog The fox is clever
fox

Output:
16 49

Test Case 6:
Input:
This is an original document with no copied content
Copied sentence

Output:
Not found

Answer

import java.util.*;
class main{
    public static void main(String[]se)
    {
        Scanner sc=new Scanner(System.in);
        try
        {
            String s=sc.nextLine().trim();
            String p=sc.nextLine().trim();
            // s=s.toLowerCase();
            // p=p.toLowerCase();
            if(!val(s)||!val(p))
            {
                 System.out.print("Invalid input");
                 return;
            }
            find(s,p);
        }
        catch(Exception e)
        {
            System.out.print("Invalid input\n");
        }
    }
    public static boolean val(String s)
    {
        return s.matches("[a-zA-Z0-9 ]+");
    }
    public static void find(String s,String p)
    {
        int n=s.length();
        int m=p.length();
        boolean f=false;
    for(int i=0;i<=n-m;i++)
    {
        if(s.substring(i,i+m).equals(p))
        {
            System.out.print(i+" ");
            f=true;
            
            
        }
    }
    if(!f)
    {
        System.out.print("Not found ");
    }
    }
}


END
Implementation of Backtracking Algorithms

N-Queens Problem with Empresses
You are a chessboard designer for a new, futuristic chess game. In this game, instead of traditional chess pieces, you have N powerful "Empresses" that can attack in all directions (horizontally, vertically, and diagonally).

Input Format

A single integer N representing the size of the chessboard and the number of queens to be placed.

Output Format
Print all possible arrangements of queens on the board. Each arrangement should be printed as an N × N grid where '1' represents a queen and '0' represents an empty space.
If no solution exists (i.e., for N = 2 or N = 3), output "No solution exists".
If the input is invalid (e.g., not an integer or outside the defined range N ≥ 9), print "Invalid input".

Constraints
1 <= N <= 20

Test cases not available
END
Implementation of Dynamic Programming

Question
You are a conservator restoring a valuable artifact that contains a sequence of ancient symbols represented by lowercase English letters. Over time, parts of the sequence have faded, and you aim to uncover the longest possible pattern that remains symmetrical (reads the same forward and backward) without altering the original order of the symbols.

Input Format
- A single string artifact consisting of lowercase English letters representing the sequence of ancient symbols.

Output Format
- A single integer representing the length of the longest symmetrical pattern in the sequence.
- Print "Invalid input" if the sequence contains any special characters or invalid symbols.

Constraints
- 1 ≤ |artifact.length| ≤ 1000

Note: int findLongestPalindromicSubsequence(const string &artifact)

Test Cases
apple
2

123abc
Invalid input

madam
5

123abc#
Invalid input

racecar
7

madam
5


Answer

import java.util.*;
class main{
    static int n;
    static int bo[];
    static boolean f=false;
    public static void main(String[]se){
        try{
            Scanner sc=new Scanner(System.in);
            n=sc.nextInt();
            if(n>=9)
            {
                System.out.print("Invalid input");
                return;
            }
            sc.close();
            bo=new int[n];
            Arrays.fill(bo,-1);
            solve(0);
            if(n==2||n==3){
                System.out.print("No solution exists");
                return;
            }
        }
        catch(Exception e){
            System.out.print("Invalid input");
        }
    }
    public static void solve(int col){
        if(col==n){
            print();
            f=true;
            return;
            
        }
        for(int ro=0;ro<n;ro++){
            if(iss(ro,col)){
                bo[col]=ro;
                solve(col+1);
                bo[col]=-1;
            }
        }
    }
    public static boolean iss(int ro,int col){
        for(int i=0;i<col;i++){
            if(bo[i]==ro||Math.abs(bo[i]-ro)==Math.abs(i-col)){
                return false;
            }
        }
        return true;
    }
    public static void print()
    {
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                System.out.print((bo[i]==j)?"1 ":"0 ");
            }
            System.out.println();
        }
        System.out.println();
    }
}

END
Implementation of Range Query Algorithms

Question
You are given an array of integers. For each range minimum query, not only do you need to find the minimum value in the specified range, but you also need to count how many times this minimum value occurs in that range.

Input Format

The first line contains an integer N, the size of the array.
The second line contains N integers, the elements of the array.
The third line contains an integer Q, the number of queries.
Each of the next Q lines contains two integers L and R, representing the range [L,R].

Output Format

For each query, print the minimum value in the range and the count of its occurrences.
Print "Invalid input", if N is negative.

Constraints

-10 ≤ N ≤ 10

1 ≤ Q ≤ 1000

0 ≤ L ≤ R < N

Test Cases

Test Case 1
Input:
6
2 8 3 8 2 8
3
1 3
2 4
0 5

Output:
3
1
2
1
2
2

Test Case 2
Input:
-8

Output:
Invalid input

Test Case 3
Input:
5
5 1 3 1 7
1
1 3

Output:
1
2

Test Case 4
Input:
5
1 3 2 2 5
2
0 2
1 4

Output:
1
1
2
2

Test Case 5
Input:
4
5 5 5 5
2
0 3
1 2

Output:
5
4
5
2

Test Case 6
Input:
5
5 1 3 1 7
1
1 3

Output:
1
2

Answer

import java.util.*;

public class RangeMinQuery {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();
        if (N < 0) {
            System.out.println("Invalid input");
            return;
            
        }
        
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = sc.nextInt();
            
        }
        
        int Q = sc.nextInt();
        while (Q-- > 0) {
            int L = sc.nextInt();
            int R = sc.nextInt();
            
            int minVal = Integer.MAX_VALUE;
            int count = 0;
            
            for (int i = L; i <= R; i++) {
                if (arr[i] < minVal) {
                    minVal = arr[i];
                    count = 1;
                    
                } else if (arr[i] == minVal) {
                    count++;
                    
                }
                
            }
            
            System.out.println(minVal);
            System.out.println(count);
            
        }
        sc.close();
        
    }
    
}

END
Implementation of Minimum Spanning Tree

Question
In a vast kingdom, cities are connected by magical roads, each with varying distances and powers. To unite the realm efficiently, a royal engineer must construct the Minimum Spanning Pathway, ensuring all cities are connected using the shortest possible roads. Using Kruskal’s wisdom, they must choose the optimal connections.

Input Format

The first line contains an integer n, the number of vertices.
The second line contains an integer e, the number of edges.
The next e lines contain three integers u, v, and w representing an edge between vertices u and v with weight w.

Output Format

Print each edge of the MST in the format "u v w" on a new line.
Print Invalid input, if n is negative.

Constraints

-10 ≤ n ≤ 10

Test Cases

Test Case 1
Input:
5
7
1 2 3
1 3 4
2 3 6
2 4 1
3 4 5
4 5 2
3 5 7

Output:
2 4 1
4 5 2
1 2 3
1 3 4

Test Case 2
Input:
-4
5
1 2 10
1 3 6
2 3 15
2 4 10
3 4 4

Output:
Invalid input

Test Case 3
Input:
5
7
1 2 10
1 3 15
2 3 20
2 4 25
3 4 30
4 5 35
3 5 40

Output:
1 2 10
1 3 15
2 4 25
4 5 35

Test Case 4
Input:
3
2
1 2 2
2 3 3

Output:
1 2 2
2 3 3

Test Case 5
Input:
5
4
1 2 3
1 3 4
2 3 5
4 5 2

Output:
4 5 2
1 2 3
1 3 4

Test Case 6
Input:
5
7
1 2 10
1 3 15
2 3 20
2 4 25
3 4 30
4 5 35
3 5 40

Output:
1 2 10
1 3 15
2 4 25
4 5 35

END
Implementation of Shortest path Algorithms

Question
A delivery company operates in a large city with multiple hubs connected by various routes. Some routes have tolls, while others are toll-free. The company wants to optimize its delivery costs by finding the cheapest route from its central hub to all other hubs. Additionally, the company needs to ensure that it considers toll-free routes wherever possible to minimize expenses.

Input Format

The first line contains two integers, n and m, the number of vertices and edges, respectively.
The next m lines each contain three integers, u, v, and w, indicating an edge from vertex u to vertex v with weight w.
The last line contains a single integer, s, the source vertex.
Print Invalid input, if n or m is negative.

Output Format

Print the shortest distance from vertex s to vertex i.
Print Invalid input, if n is negative.

Constraints

-15 ≤ n, values ≤ 15

Note

Must use function as findShortestPaths

Test Cases

Input:
5 6
0 1 4
0 2 2
1 3 5
2 1 1
2 3 8
3 4 3
0
Output:
0 3 2 8 11 

Input:
-3
Output:
Invalid input

Input:
4 6
0 1 1
0 2 0
1 2 2
1 3 4
2 3 1
3 1 0
0
Output:
0 1 0 1 

Input:
10 6
0 1 5
0 2 2
1 3 3
2 4 6
3 5 2
4 6 4
0
Output:
0 5 2 8 8 10 12 -1 -1 -1 

Input:
10 15
0 1 10
0 2 0
1 3 3
2 3 2
3 4 5
4 5 1
1 6 7
2 7 0
7 8 4
8 9 1
3 9 8
0 5 10
4 7 2
6 9 6
5 8 5
0
Output:
0 10 0 2 7 8 17 0 4 5 

Input:
4 6
0 1 1
0 2 0
1 2 2
1 3 4
2 3 1
3 1 0
0
Output:
0 1 0 1 

Answer

import java.util.*;

public class LongestSymmetricPattern {
    
    
    public static int longestSymmetricLength(String s) {
        int maxLength = 1, n = s.length();
        
        for (int i = 0; i < n; i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            maxLength = Math.max(maxLength, Math.max(len1, len2));
            
        }
        return maxLength;
        
    }
    
    public static int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
            
        }
        return right - left - 1;
        
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        if (!sc.hasNext()) {
            System.out.println("Invalid input");
            return;
            
        }
        
        String artifact = sc.next();
        if (!artifact.matches("[a-z]+")) {
            System.out.println("Invalid input");
            return;
            
        }

        System.out.println(longestSymmetricLength(artifact));
        
    }
    
}
END
// editor1
END
// editor1
import java.util.*;

public class Dijkstra {
    private static final int INF = Integer.MAX_VALUE;
    
    public static void dijkstra(int n, int m, int[][] graph, int s) {
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(dist, INF);
        dist[s] = 0;
        
        for (int itr = 0; itr < n - 1; itr++) {
            int u = -1;
            
            for (int i = 0; i < n; i++) {
                if (!visited[i] && (u == -1 || dist[i] < dist[u])) {
                    u = i;
                    
                }
                
            }
            if (dist[u] == INF) {
                break;
            }
            visited[u] = true;
            for (int v = 0; v < n; v++) {
                if (graph[u][v] != INF && !visited[v] && dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
        for (int i : dist) {
            System.out.print((i != INF ? i : -1) + " ");
            
        }
        
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
         if (n < 0) {
            System.out.println("Invalid input");
            return;
            
        }
        int m = scanner.nextInt();
        
        int[][] graph = new int[n][n];
        for (int[] row : graph) {
            Arrays.fill(row, INF);
            
        }
        for (int itr = 0; itr < m; itr++) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int w = scanner.nextInt();
            graph[u][v] = w;
            
        }
        int s = scanner.nextInt();
        scanner.close();
        dijkstra(n, m, graph, s);
    }
}
END
Implementation of Maximum Flow Minimum cut Algorithm

Question
Imagine a data center network where servers need to send data to each other. The network has a limited bandwidth capacity on each connection. You want to find the maximum amount of data that can be transferred from a source server to a destination server at any given time.

Input Format

First line of input consists of two integers, n and m, representing the number of vertices and the number of edges, respectively.
Next m lines contain three integers, u, v, and capacity, representing the source vertex, destination vertex, and capacity of an edge, respectively.
Last line of input consists of two integers, s and t, representing the source vertex and the sink vertex for the maximum flow calculation, respectively.

Output Format

Print the maximum flow value.
Print Invalid input, if n or m is negative.

Constraints

1 <= number_of_vertices <= 100
0 <= number_of_edges <= 1000
1 <= source_vertex, destination_vertex <= number_of_vertices
0 <= capacity <= 1000

Input:
4 5
1 2 10
2 4 15
1 3 20
3 4 25
2 3 6
1 4
Output:
30

Input:
-1 3
1 2 10
2 3 15
1 3 20
1 3
Output:
Invalid input

Input:
6 9
1 2 16
1 3 13
2 3 10
2 4 12
3 5 14
4 6 20
5 6 4
2 5 9
3 4 7
1 6
Output:
23

Input:
3 2
1 2 10
2 3 5
1 3
Output:
5

Input:
3 2
1 2 0
2 3 0
1 3
Output:
0

Input:
6 9
1 2 16
1 3 13
2 3 10
2 4 12
3 5 14
4 6 20
5 6 4
2 5 9
3 4 7
1 6
Output:
23
